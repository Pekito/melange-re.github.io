# Learn

## New to OCaml?

As Melange is a fork of the OCaml compiler, this documentation is designed to
include the differences between both. But for the parts that overlap between
Melange and OCaml, we will always refer to the main OCaml documentation
throughout these docs.

If you are completely new to OCaml, you might want to get familiar first with
the language, there are [plenty of resources available](https://ocaml.org/docs),
but we recommend the following tutorials from the official OCaml website:

- [A First Hour With OCaml](https://ocaml.org/docs/first-hour)
- [OCaml Exercises](https://ocaml.org/problems)

## Why Melange

Melange is a fork of the OCaml compiler that produces JavaScript.

OCaml offers an industrial-strength, state-of-the-art type system and provides
type inference with very few type annotations, proving invaluable in managing
large projects.

JavaScript is one of the most pervasive platforms to deploy and run software.
Thanks to years of efforts to improve the different VMs available, the
JavaScript code running on browsers and other environments is heavily optimized
and can support use cases for large products and tools.

Melange helps developers and companies bring the advantages of the OCaml
platform to users of the Web platform in a way that makes it easy for developers
to integrate with both ecosystems.

### A bit of history

To better understand where Melange comes from, it might help to go through some
of the related projects that have appeared over the last decade or so.

#### Js_of_ocaml

[Js_of_ocaml](https://github.com/ocsigen/js_of_ocaml/) is another OCaml to
JavaScript compiler that was made public in 2011. In [the presentation
paper](https://www.irif.fr/~balat/publications/vouillon_balat-js_of_ocaml.pdf)
published in 2013, it's explicitly mentioned that one of its design goals was to
remain as compatible as possible with the OCaml compiler, without requiring a
lot of maintenance work, as the OCaml community was not excessively large at the
time.

To achieve this goal, Js_of_ocaml picks the bytecode generated by OCaml [batch
compilation](https://ocaml.org/manual/comp.html) and generates JavaScript from
it. OCaml bytecode has a very stable interface, so Js_of_ocaml can easily
upgrade to new versions of the compiler. Due to this design decision, it can
also remain compatible with most of the OCaml ecosystem, as long as the tools or
libraries don't rely on C code.

The downside of using bytecode is that it gets harder to communicate with
existing JavaScript code. For example, a Js_of_ocaml string is not compiled as a
JavaScript string, so some conversion is needed for this and other types.

Another downside is that the resulting JavaScript is hard to read, as it is
converted from a low-level representation like bytecode.

#### BuckleScript

Then, in 2016, Bob Zhang suggests [on a Js_of_ocaml repository
issue](https://github.com/ocsigen/js_of_ocaml/issues/338) the possibility to
start converting to JavaScript from an earlier stage of the compilation process,
instead of using bytecode. This proposal fundamentally diverges from Js_of_ocaml
original design and goals, so he starts working on what will become
BuckleScript.

BuckleScript gets some inspiration from Js_of_ocaml, for example in the way that
JavaScript objects are represented with `Js.t`. But it differs from Js_of_ocaml
in many ways: it can generate more readable and lighter code. It also generates
one `.js` file per module, which makes it easier to integrate with existing
JavaScript codebases. BuckleScript puts a big emphasis on communicating with
JavaScript code through a rich collection of attributes applied to `external`
primitives.

#### Reason

Around the same year, a project called [Reason](https://reasonml.github.io/)
appears at Facebook. Led by Jordan Walke, the idea is to create an alternate
syntax for OCaml that is closer to C and JavaScript. Even if Reason has no take
on which platform the code is deployed —native applications binaries, or web
applications using JavaScript as a target language—, BuckleScript adds first
class support for Reason from early on. At that point, it becomes evident that
the combination of Reason with BuckleScript is a great match: BuckleScript
provides tools and infrastructure to work with JavaScript ecosystem, while
Reason allows developers to write their programs in a syntax they are familiar
with.

Over time, and with help of other Facebook employees and the community providing
bindings to pervasive JavaScript libraries like React.js with
[`reason-react`](https://github.com/reasonml/reason-react/), the combination of
Reason and BuckleScript gains adoption.

#### BuckleScript gets rebranded

However, at some point the goals of both BuckleScript and Reason projects become
harder to reconcile. In August 2020, the BuckleScript team decides to rename to
ReScript, stops adding support for the latest versions of the Reason parser, and
replaces it with a new parser that changes the syntax. The reasons for the
rebranding are explained in [the official ReScript blog
post](https://rescript-lang.org/blog/bucklescript-is-rebranding).

The rebranding is trying to ease onboarding and adoption of the ReScript
language, giving the project more chances to compete with mainstream
compiled-to-JavaScript languages like TypeScript. However, for many existing
users of BuckleScript and Reason, it is the explicit confirmation of something
that had been hinted implicitly before: ReScript goals are not compatible with
providing a good integration with the OCaml ecosystem.

#### Melange: back to OCaml

This is where Melange comes in. A few weeks after the rebranding of BuckleScript
to ReScript, António Monteiro starts working on a fork of BuckleScript with a
simple (not easy) goal: replace the [Ninja build
system](https://ninja-build.org/), which BuckleScript had been using from its
creation, with [Dune](https://dune.build/), which is the most used build system
for OCaml projects.

This fork of BuckleScript is later named Melange. After finishing the switch
from Ninja to Dune, several additional features were added to bring it closer to
OCaml. Some examples are the upgrade of the compiler version used by Melange to
4.12, or modelling the changes to the OCaml compiler that Melange uses as just a
plain library, instead of a full fork of the whole compiler.

## Build system and package management

_TODO: Explain compilation model (1:1 ml/js), dual npm/opam setup, intro to
opam, intro to dune._

## Communicate with JavaScript

_TODO: Sections will be something like:_
```
- intro: explain attributes, extensions, and `bs.` backwards compatibility
- `melange.ppx` preprocessor and extensions
- data types
- call javascript from melange:
  - intro to external (link to OCaml docs)
  - bindings with external (to functions, objects or other values)
  - global values
- call melange from javascript
```

## Additions to OCaml
_TODO: pipe first_

## Melange for X users

_TODO: For ReScript users, for OCaml users, for TypeScript/JavaScript users._
